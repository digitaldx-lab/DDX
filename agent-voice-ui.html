<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Agent Voice UI — Live Speaking Animation</title>
<style>
  :root{
    --bg:#0f1724;
    --card:#0b1220;
    --accent:#7c5cff;
    --muted:#98a0b3;
    --glass: rgba(255,255,255,0.03);
    --glass2: rgba(255,255,255,0.02);
  }
  html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;color:#e6eef8;background:linear-gradient(180deg,#071025 0%, var(--bg) 100%);-webkit-font-smoothing:antialiased}
  .wrap{
    min-height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:48px;
    box-sizing:border-box;
    gap:28px;
  }

  .panel{
    width:880px;
    max-width:calc(100% - 48px);
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:16px;
    padding:28px;
    box-shadow: 0 10px 30px rgba(2,6,23,0.6), inset 0 1px 0 rgba(255,255,255,0.02);
    display:grid;
    grid-template-columns: 320px 1fr;
    gap:20px;
    align-items:stretch;
    border: 1px solid rgba(255,255,255,0.03);
  }

  /* Left avatar column */
  .avatar-card{
    background: linear-gradient(180deg, var(--glass2), transparent);
    border-radius:12px;
    padding:18px;
    display:flex;
    flex-direction:column;
    gap:12px;
    align-items:center;
    justify-content:center;
    position:relative;
    overflow:hidden;
  }
  .avatar{
    width:180px;height:180px;
    display:grid;
    place-items:center;
    transform-origin:center;
  }

  /* A minimal stylized face using SVG */
  svg.face { width:160px; height:160px; display:block; }
  .eye { transition: transform .18s linear; transform-origin:center; }
  .mouth { transform-origin: center top; transition: transform 0.08s cubic-bezier(.2,.9,.2,1); }
  .face-bg { filter: drop-shadow(0 8px 16px rgba(0,0,0,0.6)); }

  .status {
    font-size:13px; color:var(--muted);
  }

  .controls {
    display:flex; gap:8px; margin-top:8px;
  }
  button {
    background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
    border: 1px solid rgba(255,255,255,0.04);
    color: #eaf0ff;
    padding:10px 14px;
    border-radius:10px;
    cursor:pointer;
    font-weight:600;
    transition: transform .12s ease, box-shadow .12s ease, background .12s ease;
  }
  button:active { transform: translateY(1px) scale(.995); }
  .btn-primary { background: linear-gradient(90deg, var(--accent), #5dd0ff); box-shadow: 0 8px 30px rgba(124,92,255,0.12); color:#071025; }
  .btn-danger { background: linear-gradient(90deg, #ff6b6b, #ff9b6b); color:#071025; }

  /* Right column - waveform and transcript */
  .right {
    display:flex; flex-direction:column; gap:12px;
  }
  .waveframe {
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:12px;
    padding:14px;
    height:220px;
    display:flex;
    flex-direction:column;
    gap:10px;
    align-items:stretch;
    justify-content:center;
    border: 1px solid rgba(255,255,255,0.03);
  }
  canvas#wave { width:100%; height:120px; border-radius:8px; background: linear-gradient(180deg,#071022, #0a1726); box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); }
  .vumeter {
    height:14px; border-radius:8px; background:rgba(255,255,255,0.03); overflow:hidden; width:100%;
  }
  .vu-fill {
    height:100%;
    width:0%;
    background: linear-gradient(90deg, #6dd3ff, var(--accent));
    transition: width 0.12s linear;
  }
  .transcript {
    margin-top:6px;
    background: linear-gradient(180deg,#071026, rgba(255,255,255,0.01));
    padding:12px;
    border-radius:10px;
    box-shadow: 0 6px 18px rgba(4,8,16,0.6);
    color: #e9f2ff;
    font-weight:600;
    letter-spacing:0.2px;
  }
  .transcript small { display:block; color:var(--muted); font-weight:500; margin-bottom:6px; font-size:12px; }

  /* subtle moving gradient backdrop behind avatar */
  .orb {
    position:absolute; left:-20%; top:-40%; width:260px; height:260px; border-radius:50%;
    background: radial-gradient(circle at 30% 30%, rgba(124,92,255,0.18), transparent 30%),
                radial-gradient(circle at 70% 70%, rgba(93,208,255,0.09), transparent 20%);
    filter: blur(30px);
    transform: rotate(8deg);
    pointer-events:none;
  }

  /* footer */
  .footer { font-size:12px; color:var(--muted); margin-top:8px; text-align:center; }

  /* responsive */
  @media (max-width:880px){
    .panel{ grid-template-columns: 1fr; padding:18px; width:100%;}
    .avatar-card{ order:2 }
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="panel" role="application" aria-label="Agent voice UI prototype">
      <div class="avatar-card" aria-hidden="false">
        <div class="orb" aria-hidden="true"></div>

        <div class="avatar" id="avatar">
          <!-- SVG face -->
          <svg class="face" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
            <defs>
              <linearGradient id="skin" x1="0" x2="1">
                <stop offset="0" stop-color="#0f1c2b"/>
                <stop offset="1" stop-color="#09121a"/>
              </linearGradient>
              <filter id="soft" x="-50%" y="-50%" width="200%" height="200%">
                <feGaussianBlur stdDeviation="6" result="b"/>
                <feComposite in="b" in2="SourceGraphic" operator="over"/>
              </filter>
            </defs>
            <g class="face-bg">
              <circle cx="100" cy="100" r="72" fill="url(#skin)"/>
            </g>
            <!-- eyes -->
            <g transform="translate(0,-6)">
              <ellipse class="eye" id="eyeL" cx="70" cy="92" rx="9" ry="10" fill="#eaf1ff" />
              <ellipse class="eye" id="eyeR" cx="130" cy="92" rx="9" ry="10" fill="#eaf1ff" />
              <circle cx="70" cy="92" r="4" fill="#071025"/>
              <circle cx="130" cy="92" r="4" fill="#071025"/>
            </g>
            <!-- mouth -->
            <g transform="translate(0,10)">
              <path id="mouth" class="mouth" d="M70,128 Q100,138 130,128 Q100,148 70,128 Z" fill="#ffb3b3" opacity="0.98"/>
            </g>
            <!-- subtle glossy -->
            <ellipse cx="72" cy="72" rx="28" ry="16" fill="rgba(255,255,255,0.02)"/>
          </svg>
        </div>

        <div class="status" id="status">Microphone: <strong id="micStatus">stopped</strong></div>
        <div class="controls" role="toolbar" aria-label="controls">
          <button id="startBtn" class="btn-primary" title="Start microphone (grants access)">Start listening</button>
          <button id="stopBtn" class="btn-danger" disabled>Stop</button>
        </div>
        <div class="footer">Real-time speaking animation — volume-driven lip & waveform demo</div>
      </div>

      <div class="right">
        <div class="waveframe" aria-live="polite">
          <canvas id="wave"></canvas>
          <div class="vumeter" aria-hidden="false">
            <div class="vu-fill" id="vuFill" style="width:0%"></div>
          </div>

          <div class="transcript" id="transcript">
            <small>Detected utterance (sample):</small>
            <div id="sampleText" style="font-size:16px;line-height:1.3">Welcome</div>
          </div>
        </div>

        <div style="display:flex;gap:12px;align-items:center;justify-content:space-between">
          <div style="color:var(--muted)">Tip: speak naturally — mouth scales with volume and waveform smooths peaks.</div>
          <div>
            <button id="simulateBtn">Simulate sample speech</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(async function(){
  // Elements
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const micStatus = document.getElementById('micStatus');
  const vuFill = document.getElementById('vuFill');
  const canvas = document.getElementById('wave');
  const sampleText = document.getElementById('sampleText');
  const avatar = document.getElementById('avatar');
  const mouth = document.getElementById('mouth');
  const eyeL = document.getElementById('eyeL');
  const eyeR = document.getElementById('eyeR');
  const simulateBtn = document.getElementById('simulateBtn');

  let audioCtx = null;
  let analyser = null;
  let dataArray = null;
  let source = null;
  let micStream = null;
  let rafId = null;
  const canvasCtx = canvas.getContext('2d');

  // Resize canvas nicely
  function resizeCanvas(){ canvas.width = canvas.clientWidth * devicePixelRatio; canvas.height = canvas.clientHeight * devicePixelRatio; canvasCtx.scale(devicePixelRatio, devicePixelRatio); }
  window.addEventListener('resize', ()=>{ resizeCanvas(); drawSilence(); });
  resizeCanvas();

  // helper: smooth running average
  function smooth(value, prev, alpha=0.12){ return prev === undefined ? value : (alpha*value + (1-alpha)*prev); }
  let smoothLevel = 0;

  // draw silence baseline
  function drawSilence(){
    canvasCtx.clearRect(0,0,canvas.width,canvas.height);
    const w = canvas.clientWidth, h = canvas.clientHeight;
    canvasCtx.fillStyle = 'rgba(255,255,255,0.02)';
    canvasCtx.fillRect(0,0,w,h);
    canvasCtx.fillStyle = 'rgba(255,255,255,0.03)';
    canvasCtx.fillRect(0,h/2 - 1, w, 2);
  }
  drawSilence();

  // create analyser
  function createAnalyser(ctx){
    const an = ctx.createAnalyser();
    an.fftSize = 2048;
    an.smoothingTimeConstant = 0.85; // smooth the waveform
    return an;
  }

  // update UI based on level (0..1)
  function updateAvatar(level){
    // mouth scale: minimal when quiet, larger when loud
    const min = 0.02, max = 0.9;
    const scale = Math.max(min, Math.min(max, level * 1.6));
    mouth.style.transform = `translateY(0px) scaleY(${1 + scale})`;
    // eyes subtle squint
    const eyeScale = 1 - Math.min(0.22, level * 0.3);
    eyeL.style.transform = `scaleY(${eyeScale})`;
    eyeR.style.transform = `scaleY(${eyeScale})`;
    // avatar "breathing" using transform scale for a lively effect
    const baseBreath = 1 + Math.sin(Date.now() / 1600) * 0.007;
    avatar.style.transform = `scale(${baseBreath})`;
  }

  // draw waveform
  function draw(){
    if(!analyser) return;
    const w = canvas.clientWidth, h = canvas.clientHeight;
    canvasCtx.clearRect(0,0, w, h);
    // background
    const bg = canvasCtx.createLinearGradient(0,0,0,h);
    bg.addColorStop(0, 'rgba(11,19,30,0.0)');
    bg.addColorStop(1, 'rgba(6,14,22,0.0)');
    canvasCtx.fillStyle = bg;
    canvasCtx.fillRect(0,0,w,h);

    // get waveform
    analyser.getByteTimeDomainData(dataArray);
    // compute RMS for VU
    let sum = 0;
    for(let i=0;i<dataArray.length;i++){
      const v = (dataArray[i] - 128) / 128; sum += v*v;
    }
    const rms = Math.sqrt(sum / dataArray.length); // 0..1
    smoothLevel = smooth(rms, smoothLevel, 0.18);

    // draw gradient stroke
    const grad = canvasCtx.createLinearGradient(0,0,w,0);
    grad.addColorStop(0, '#6dd3ff');
    grad.addColorStop(0.5, 'var(--accent)');
    grad.addColorStop(1, '#7c5cff');
    canvasCtx.lineWidth = 2;
    canvasCtx.strokeStyle = grad;

    canvasCtx.beginPath();
    const slice = w / dataArray.length;
    for(let i=0;i<dataArray.length;i++){
      const v = (dataArray[i] - 128) / 128;
      const y = h/2 + v * (h/2 - 10);
      const x = i * slice;
      if(i===0) canvasCtx.moveTo(x,y);
      else canvasCtx.lineTo(x,y);
    }
    canvasCtx.stroke();

    // fill under curve softly
    canvasCtx.lineTo(w, h); canvasCtx.lineTo(0, h); canvasCtx.closePath();
    const fillGrad = canvasCtx.createLinearGradient(0,0,0,h);
    fillGrad.addColorStop(0, 'rgba(124,92,255,0.06)');
    fillGrad.addColorStop(1, 'rgba(13,25,36,0.02)');
    canvasCtx.fillStyle = fillGrad;
    canvasCtx.fill();

    // update VU meter
    const percent = Math.min(1, smoothLevel * 2.2);
    vuFill.style.width = `${(percent * 100).toFixed(1)}%`;

    // update avatar
    updateAvatar(percent);

    // next frame
    rafId = requestAnimationFrame(draw);
  }

  // start capturing microphone
  async function startMic(){
    try{
      if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      micStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation:true, noiseSuppression:true }, video:false });
      source = audioCtx.createMediaStreamSource(micStream);
      analyser = createAnalyser(audioCtx);
      source.connect(analyser);
      dataArray = new Uint8Array(analyser.fftSize);
      micStatus.textContent = 'listening';
      startBtn.disabled = true;
      stopBtn.disabled = false;
      // resume ctx if suspended (Chrome autoplay policies)
      if(audioCtx.state === 'suspended') await audioCtx.resume();
      draw();
    }catch(err){
      console.error('Mic start failed', err);
      alert('Unable to access microphone: ' + (err.message || err));
      micStatus.textContent = 'error';
    }
  }

  // stop capturing
  function stopMic(){
    if(micStream){
      micStream.getTracks().forEach(t => t.stop());
      micStream = null;
    }
    if(source) { try{ source.disconnect(); }catch(e){} source=null; }
    if(analyser){ analyser.disconnect(); analyser=null; }
    if(rafId){ cancelAnimationFrame(rafId); rafId = null; }
    vuFill.style.width = '0%';
    micStatus.textContent = 'stopped';
    startBtn.disabled = false;
    stopBtn.disabled = true;
    drawSilence();
    // reset mouth/eyes gently
    mouth.style.transform = 'translateY(0px) scaleY(1)';
    eyeL.style.transform = 'scaleY(1)';
    eyeR.style.transform = 'scaleY(1)';
  }

  startBtn.addEventListener('click', startMic);
  stopBtn.addEventListener('click', stopMic);

  // Simulate sample speech: animates avatar & wave using synthetic oscillator
  simulateBtn.addEventListener('click', async ()=>{
    // flash the transcript text, animate mouth periodically
    const phrase = sampleText.textContent.trim();
    sampleText.style.opacity = '0.95';
    // use an offline oscillator to pump the analyser if available,
    // but easier: animate mouth on a schedule mimicking syllables
    const syllables = Math.max(6, Math.round(phrase.split(/\s+/).length * 1.8));
    let i = 0;
    const int = setInterval(()=>{
      const level = 0.15 + Math.abs(Math.sin(i * 0.8)) * 0.9;
      updateAvatar(Math.min(1, level));
      vuFill.style.width = `${Math.min(1, level)*100}%`;
      i++;
      if(i > syllables*2){
        clearInterval(int);
        // settle back
        const settle = setInterval(()=>{
          updateAvatar(0.02);
          vuFill.style.width = `0%`;
          clearInterval(settle);
        }, 120);
      }
    }, 120);
  });

  // Draw initial gentle idle animation
  (function idleLoop(){
    const level = 0.02 + Math.max(0, Math.sin(Date.now() / 1500)) * 0.02;
    updateAvatar(level);
    requestAnimationFrame(idleLoop);
  })();

})();
</script>
</body>
</html>
